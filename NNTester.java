import java.io.*;
import java.util.*;
import java.nio.*;

public class NNTester{
    public static final int TESTING_NUM = 10000;
    public NNetwork net;
    private int[][][] inputs;
    private int[] targets;
    private MNISTReader reader;
    
    public static final int NUM_LAYERS = 3;
    public static final int NUM_IN_NODES = 784;
    
    public static int NUM_HID_NODES;
    public static int NUM_OUT_NODES;
    
    public static final double THRESH_0 = 0.7890201293436911;
    public static final double THRESH_1 = 0.7134844093219632;
    public static final double THRESH_2 = 0.6243163277178357;
    public static final double THRESH_3 = 0.71000569875303;
    
    public static final double THRESH_FIRE = 0.7156377158017291;
    public static final double THRESH_NOT_FIRE = 0.15462546189776147;
    public static final double THRESH_BOTH = 0.3680417767306088;
    public static final double THRESH_MID = 0.542;
    
    
    
    public NNTester(){
        this.inputs = new int[TESTING_NUM][28][28];
        this.targets = new int[TESTING_NUM];
        reader = new MNISTReader(inputs, targets, 1);
        net = new NNetwork(NUM_LAYERS,NUM_IN_NODES,NUM_HID_NODES,NUM_OUT_NODES,0.0);
        try{
            reader.Read();
        }catch(IOException e){}
        
    }
    
    public static void main (String[]args) {
        
        String fileName = args[0];
        // typical number of hidden nodes is 50
        int numberHiddenNodes = Integer.parseInt(args[1]);
        // number of output nodes must be either 10 (decimal) or 4 (binary)
        int numberOutputNodes = Integer.parseInt(args[2]);
        // binary test type must be 0 - 5 (6 different tests in total)
        int binaryTestType = Integer.parseInt(args[3]);
        
        NUM_HID_NODES = numberHiddenNodes;
        NUM_OUT_NODES = numberOutputNodes;
        
        // initialize tester
        NNTester T = new NNTester();
        
        // initialize weights
        double[] weights = new double[NUM_IN_NODES*(NUM_HID_NODES-1) + NUM_HID_NODES*NUM_OUT_NODES];
        
        // input weights (from a text file generated by previous training)
        try{
            BufferedReader br = new BufferedReader(new FileReader(fileName));
            String line;
            for (int i = 0; i < NUM_IN_NODES*(NUM_HID_NODES-1) + NUM_HID_NODES*NUM_OUT_NODES; i++) {
                line = br.readLine();
                weights[i] = Double.parseDouble(line);
            }
            br.close();
            br = null;
        }catch(IOException e){}
        
        // set weights
        T.net.setAllWeights(weights);
        
        // run test
        T.test(binaryTestType);
        
        // *** UNCOMMENT EITHER METHOD TO USE *** //
        // these methods are used to retrieve different types of averages of output values
        //        T.getThreshold();
        //        T.getOppositeThreshold();
        //        T.getCompositeThreshold();
    }
    
    public void test(int type){
        double correct = 0;
        double totalTargetOutputValues = 0;
        
        // iterate through images
        for(int image = 0; image < TESTING_NUM; image++) {
            int tar = this.targets[image];
            int[][] in = this.inputs[image];
            this.net.setInputs(in);
            this.net.feedForward();
            
            // if decimal output
            if(NUM_OUT_NODES == 10){
                double maxVal = 0;
                int maxIndx = 0;
                double[] temp = this.net.getOutputs();
                // retrieve max output value
                for(int o = 0; o < NUM_OUT_NODES; o++){
                    if(temp[o] > maxVal){
                        maxVal = temp[o];
                        maxIndx = o;
                    }
                }
                // increment the number of correct tests if the max value is at the correct node
                if(maxIndx == tar){correct++;}
                totalTargetOutputValues += temp[tar];
            }
            // if binary style output
            else if (NUM_OUT_NODES == 4) {
                double[] temp = this.net.getOutputs();
                // adjustable constants used to optimize different styles of testing
                double a = -0.3;
                double b = 0.0;
                double d = 0.0;
                
                switch (type) {
                    // tests if output is correct based on the middle value between the averages of firing and non-firing nodes
                    // checks if each firing node is above the value -d
                    // checks if each firing node is below the value +d
                    case 0:
                        d = 0.0;
                        switch(tar){
                            case 0: if (temp[0] < THRESH_MID+d && temp[1] < THRESH_MID+d && temp[2] < THRESH_MID+d && temp[3] < THRESH_MID+d) {correct++;}
                                break;
                            case 1: if (temp[0] > THRESH_MID-d && temp[1] < THRESH_MID+d && temp[2] < THRESH_MID+d && temp[3] < THRESH_MID+d) {correct++;}
                                break;
                            case 2: if (temp[0] < THRESH_MID+d && temp[1] > THRESH_MID-d && temp[2] < THRESH_MID+d && temp[3] < THRESH_MID+d) {correct++;}
                                break;
                            case 3: if (temp[0] > THRESH_MID-d && temp[1] > THRESH_MID-d && temp[2] < THRESH_MID+d && temp[3] < THRESH_MID+d) {correct++;}
                                break;
                            case 4: if (temp[0] < THRESH_MID+d && temp[1] < THRESH_MID+d && temp[2] > THRESH_MID-d && temp[3] < THRESH_MID+d) {correct++;}
                                break;
                            case 5: if (temp[0] > THRESH_MID-d && temp[1] < THRESH_MID+d && temp[2] > THRESH_MID-d && temp[3] < THRESH_MID+d) {correct++;}
                                break;
                            case 6: if (temp[0] < THRESH_MID+d && temp[1] > THRESH_MID-d && temp[2] > THRESH_MID-d && temp[3] < THRESH_MID+d) {correct++;}
                                break;
                            case 7: if (temp[0] > THRESH_MID-d && temp[1] > THRESH_MID-d && temp[2] > THRESH_MID-d && temp[3] < THRESH_MID+d) {correct++;}
                                break;
                            case 8: if (temp[0] < THRESH_MID+d && temp[1] < THRESH_MID+d && temp[2] < THRESH_MID+d && temp[3] > THRESH_MID-d) {correct++;}
                                break;
                            case 9: if (temp[0] > THRESH_MID-d && temp[1] < THRESH_MID+d && temp[2] < THRESH_MID+d && temp[3] > THRESH_MID-d) {correct++;}
                                break;
                            default:
                                break;
                        }
                        break;
                    // tests if output is correct based on the the average firing value for each node
                    // checks if each firing node is above the value -d
                    // checks if each firing node is below the value -b
                    case 1:
                        d = 0.2;
                        b = 0.4;
                        switch(tar){
                            case 0: if (temp[0] < THRESH_0-b && temp[1] < THRESH_1-b && temp[2] < THRESH_2-b && temp[3] < THRESH_3-b) {correct++;}
                                break;
                            case 1: if (temp[0] > THRESH_0-d && temp[1] < THRESH_1-b && temp[2] < THRESH_2-b && temp[3] < THRESH_3-b) {correct++;}
                                break;
                            case 2: if (temp[0] < THRESH_0-b && temp[1] > THRESH_1-d && temp[2] < THRESH_2-b && temp[3] < THRESH_3-b) {correct++;}
                                break;
                            case 3: if (temp[0] > THRESH_0-d && temp[1] > THRESH_1-d && temp[2] < THRESH_2-b && temp[3] < THRESH_3-b) {correct++;}
                                break;
                            case 4: if (temp[0] < THRESH_0-b && temp[1] < THRESH_1-b && temp[2] > THRESH_2-d && temp[3] < THRESH_3-b) {correct++;}
                                break;
                            case 5: if (temp[0] > THRESH_0-d && temp[1] < THRESH_1-b && temp[2] > THRESH_2-d && temp[3] < THRESH_3-b) {correct++;}
                                break;
                            case 6: if (temp[0] < THRESH_0-b && temp[1] > THRESH_1-d && temp[2] > THRESH_2-d && temp[3] < THRESH_3-b) {correct++;}
                                break;
                            case 7: if (temp[0] > THRESH_0-d && temp[1] > THRESH_1-d && temp[2] > THRESH_2-d && temp[3] < THRESH_3-b) {correct++;}
                                break;
                            case 8: if (temp[0] < THRESH_0-b && temp[1] < THRESH_1-b && temp[2] < THRESH_2-b && temp[3] > THRESH_3-d) {correct++;}
                                break;
                            case 9: if (temp[0] > THRESH_0-d && temp[1] < THRESH_1-b && temp[2] < THRESH_2-b && temp[3] > THRESH_3-d) {correct++;}
                                break;
                            default:
                                break;
                        }
                        break;
                    // tests if output is correct based on the the average output value of ALL nodes
                    // checks if each firing node is above the value +d
                    // checks if each firing node is below the value +d
                    case 2:
                        d = 0.1;
                        switch(tar){
                            case 0: if (temp[0] < THRESH_BOTH+d && temp[1] < THRESH_BOTH+d && temp[2] < THRESH_BOTH+d && temp[3] < THRESH_BOTH+d) {correct++;}
                                break;
                            case 1: if (temp[0] > THRESH_BOTH+d && temp[1] < THRESH_BOTH+d && temp[2] < THRESH_BOTH+d && temp[3] < THRESH_BOTH+d) {correct++;}
                                break;
                            case 2: if (temp[0] < THRESH_BOTH+d && temp[1] > THRESH_BOTH+d && temp[2] < THRESH_BOTH+d && temp[3] < THRESH_BOTH+d) {correct++;}
                                break;
                            case 3: if (temp[0] > THRESH_BOTH+d && temp[1] > THRESH_BOTH+d && temp[2] < THRESH_BOTH+d && temp[3] < THRESH_BOTH+d) {correct++;}
                                break;
                            case 4: if (temp[0] < THRESH_BOTH+d && temp[1] < THRESH_BOTH+d && temp[2] > THRESH_BOTH+d && temp[3] < THRESH_BOTH+d) {correct++;}
                                break;
                            case 5: if (temp[0] > THRESH_BOTH+d && temp[1] < THRESH_BOTH+d && temp[2] > THRESH_BOTH+d && temp[3] < THRESH_BOTH+d) {correct++;}
                                break;
                            case 6: if (temp[0] < THRESH_BOTH+d && temp[1] > THRESH_BOTH+d && temp[2] > THRESH_BOTH+d && temp[3] < THRESH_BOTH+d) {correct++;}
                                break;
                            case 7: if (temp[0] > THRESH_BOTH+d && temp[1] > THRESH_BOTH+d && temp[2] > THRESH_BOTH+d && temp[3] < THRESH_BOTH+d) {correct++;}
                                break;
                            case 8: if (temp[0] < THRESH_BOTH+d && temp[1] < THRESH_BOTH+d && temp[2] < THRESH_BOTH+d && temp[3] > THRESH_BOTH+d) {correct++;}
                                break;
                            case 9: if (temp[0] > THRESH_BOTH+d && temp[1] < THRESH_BOTH+d && temp[2] < THRESH_BOTH+d && temp[3] > THRESH_BOTH+d) {correct++;}
                                break;
                            default:
                                break;
                        }
                        break;
                    // tests if output is correct based on the the average firing value for each node
                    // checks if each firing node is above the value -d
                    // checks if each firing node is below the value -d
                    case 3:
                        d = 0.3;
                        switch(tar){
                            case 0: if (temp[0] < THRESH_0-d && temp[1] < THRESH_1-d && temp[2] < THRESH_2-d && temp[3] < THRESH_3-d) {correct++;}
                                break;
                            case 1: if (temp[0] > THRESH_0-d && temp[1] < THRESH_1-d && temp[2] < THRESH_2-d && temp[3] < THRESH_3-d) {correct++;}
                                break;
                            case 2: if (temp[0] < THRESH_0-d && temp[1] > THRESH_1-d && temp[2] < THRESH_2-d && temp[3] < THRESH_3-d) {correct++;}
                                break;
                            case 3: if (temp[0] > THRESH_0-d && temp[1] > THRESH_1-d && temp[2] < THRESH_2-d && temp[3] < THRESH_3-d) {correct++;}
                                break;
                            case 4: if (temp[0] < THRESH_0-d && temp[1] < THRESH_1-d && temp[2] > THRESH_2-d && temp[3] < THRESH_3-d) {correct++;}
                                break;
                            case 5: if (temp[0] > THRESH_0-d && temp[1] < THRESH_1-d && temp[2] > THRESH_2-d && temp[3] < THRESH_3-d) {correct++;}
                                break;
                            case 6: if (temp[0] < THRESH_0-d && temp[1] > THRESH_1-d && temp[2] > THRESH_2-d && temp[3] < THRESH_3-d) {correct++;}
                                break;
                            case 7: if (temp[0] > THRESH_0-d && temp[1] > THRESH_1-d && temp[2] > THRESH_2-d && temp[3] < THRESH_3-d) {correct++;}
                                break;
                            case 8: if (temp[0] < THRESH_0-d && temp[1] < THRESH_1-d && temp[2] < THRESH_2-d && temp[3] > THRESH_3-d) {correct++;}
                                break;
                            case 9: if (temp[0] > THRESH_0-d && temp[1] < THRESH_1-d && temp[2] < THRESH_2-d && temp[3] > THRESH_3-d) {correct++;}
                                break;
                            default:
                                break;
                        }
                        break;
                    // tests if output is correct based on the the relative sizes of the outputs
                    // checks if each firing node is above each non-firing node
                    // can be scaled by a
                    case 4:
                        a = 0.0;
                        switch(tar){
                            case 0: if (temp[0] < THRESH_0-a && temp[1] < THRESH_1-a && temp[2] < THRESH_2-a && temp[3] < THRESH_3-a) {correct++;}
                                break;
                            case 1: if (temp[0] > temp[1]+a && temp[0] > temp[2]+a && temp[0] > temp[3]+a) {correct++;}
                                break;
                            case 2: if (temp[1] > temp[0]+a && temp[1] > temp[2]+a && temp[1] > temp[3]+a) {correct++;}
                                break;
                            case 3: if (temp[0] > temp[2]+a && temp[0] > temp[3]+a && temp[1] > temp[2]+a && temp[1] > temp[3]+a) {correct++;}
                                break;
                            case 4: if (temp[2] > temp[0]+a && temp[2] > temp[1]+a && temp[2] > temp[3]+a) {correct++;}
                                break;
                            case 5: if (temp[0] > temp[1]+a && temp[0] > temp[3]+a && temp[2] > temp[1]+a && temp[2] > temp[3]+a) {correct++;}
                                break;
                            case 6: if (temp[1] > temp[0]+a && temp[1] > temp[3]+a && temp[2] > temp[0]+a && temp[2] > temp[3]+a) {correct++;}
                                break;
                            case 7: if (temp[0] > temp[3]+a && temp[1] > temp[3]+a && temp[2] > temp[3]+a) {correct++;}
                                break;
                            case 8: if (temp[3] > temp[0]+a && temp[3] > temp[1]+a && temp[3] > temp[2]+a) {correct++;}
                                break;
                            case 9: if (temp[0] > temp[1]+a && temp[0] > temp[2]+a && temp[3] > temp[1]+a && temp[3] > temp[2]+a) {correct++;}
                                break;
                            default:
                                break;
                        }
                        break;
                    // tests if output is correct based on the the relative sizes of the outputs
                    // checks if each firing node is above each non-firing node purely by boolean (a little simpler)
                    case 5:
                        switch(tar){
                            case 0: if (temp[0] < THRESH_FIRE && temp[1] < THRESH_FIRE && temp[2] < THRESH_FIRE && temp[3] < THRESH_FIRE) {correct++;}
                                break;
                            case 1: if (greaterThanThree(temp[0],temp[1],temp[2],temp[3])) {correct++;}
                                break;
                            case 2: if (greaterThanThree(temp[1],temp[0],temp[2],temp[3])) {correct++;}
                                break;
                            case 3: if (greaterPairs(temp[0],temp[1],temp[2],temp[3])) {correct++;}
                                break;
                            case 4: if (greaterThanThree(temp[2],temp[0],temp[1],temp[3])) {correct++;}
                                break;
                            case 5: if (greaterPairs(temp[0],temp[2],temp[1],temp[3])) {correct++;}
                                break;
                            case 6: if (greaterPairs(temp[1],temp[2],temp[0],temp[3])) {correct++;}
                                break;
                            case 7: if (lessThanThree(temp[3],temp[0],temp[1],temp[2])) {correct++;}
                                break;
                            case 8: if (greaterThanThree(temp[3],temp[0],temp[1],temp[2])) {correct++;}
                                break;
                            case 9: if (greaterPairs(temp[0],temp[3],temp[1],temp[2])) {correct++;}
                                break;
                            default:
                                break;
                        }
                        break;
                        
                    default:
                        break;
                        
                }
            }
        }
        if(NUM_OUT_NODES == 10){
            double percentError = ((double)TESTING_NUM-correct)/(double)TESTING_NUM * 100.0;
            System.out.println();
            System.out.println("TOTAL CORRECT "+correct);
            System.out.println("PERCENT ERROR "+percentError);
            System.out.println();
            double averageTargetOutputValue = totalTargetOutputValues/TESTING_NUM;
            System.out.println("AVERAGE TARGET OUTPUT VALUE "+averageTargetOutputValue);
            System.out.println();
        }
        else if(NUM_OUT_NODES == 4){
            double percentError = ((double)TESTING_NUM-correct)/(double)TESTING_NUM * 100.0;
            System.out.println();
            System.out.println("TOTAL CORRECT "+correct);
            System.out.println("PERCENT ERROR "+percentError);
            System.out.println();
        }
    }
    
    // returns true if the first input is less than each of the following three
    public boolean lessThanThree(double a, double b, double c, double d) {
        return a < b && a < c && a < d;
    }
    // returns true if the first input is greater than each of the following three
    public boolean greaterThanThree(double a, double b, double c, double d) {
        return a > b && a > c && a > d;
    }
    // returns true if the first pair of inputs is greater than the following pair
    public boolean greaterPairs(double a, double b, double c, double d) {
        return a > c && a > d && b > c && b > d;
    }
    
    // this method creates and writes to a file the average output for ALL nodes
    public void getCompositeThreshold() {
        double threshold = 0;
        int count = 0;
        
        for(int image = 0; image < TESTING_NUM; image++) {
            int tar = this.targets[image];
            int[][] in = this.inputs[image];
            this.net.setInputs(in); //set the inputs for this TESTING epoch
            this.net.feedForward();
            
            double[] temp = this.net.getOutputs();
            
            for (int i = 0; i < 4; i++) {
                threshold += temp[i];
                count++;
            }
        }
        PrintWriter writer;
        try{
            writer = new PrintWriter("compositeThreshold.txt", "UTF-8");
            writer.println("Composite threshold: "+threshold/(double)count);
            writer.close();
        }catch(IOException e){}
        
    }
    
    // this method creates and writes to a file the average output for non-firing nodes
    public void getOppositeThreshold() {
        double notFireThreshold = 0;
        int notFireCount = 0;
        
        for(int image = 0; image < TESTING_NUM; image++) {
            int tar = this.targets[image];
            int[][] in = this.inputs[image];
            this.net.setInputs(in); //set the inputs for this TESTING epoch
            this.net.feedForward();
            
            double[] temp = this.net.getOutputs();
            
            switch(tar) {
                case 0:
                    notFireThreshold += temp[0] + temp[1] + temp[2] + temp[3];
                    notFireCount += 4;
                    break;
                case 1:
                    notFireThreshold += temp[1] + temp[2] + temp[3];
                    notFireCount += 3;
                    break;
                case 2:
                    notFireThreshold += temp[0] + temp[2] + temp[3];
                    notFireCount += 3;
                    break;
                case 3:
                    notFireThreshold += temp[2] + temp[3];
                    notFireCount += 2;
                    break;
                case 4:
                    notFireThreshold += temp[0] + temp[1] + temp[3];
                    notFireCount += 3;
                    break;
                case 5:
                    notFireThreshold +=+ temp[1] + temp[3];
                    notFireCount += 2;
                    break;
                case 6:
                    notFireThreshold += temp[0] + temp[3];
                    notFireCount += 2;
                    break;
                case 7:
                    notFireThreshold += temp[3];
                    notFireCount += 1;
                    break;
                case 8:
                    notFireThreshold += temp[0] + temp[1] + temp[2];
                    notFireCount += 3;
                    break;
                case 9:
                    notFireThreshold += temp[1] + temp[2];
                    notFireCount += 2;
                    break;
                default:
                    break;
            }
        }
        PrintWriter writer;
        try{
            writer = new PrintWriter("oppositeThreshold.txt", "UTF-8");
            writer.println("Opposite threshold: "+notFireThreshold/(double)notFireCount);
            writer.close();
        }catch(IOException e){}
        
        
    }
    
    // this method creates and writes to a file the average output for
    // all firing nodes and for each node when it fires
    public void getThreshold(){
        
        double fireThreshold = 0;
        int fireCount = 0;
        
        double zeroFireThreshold = 0;
        double oneFireThreshold = 0;
        double twoFireThreshold = 0;
        double threeFireThreshold = 0;
        
        int zeroFireCount = 0;
        int oneFireCount = 0;
        int twoFireCount = 0;
        int threeFireCount = 0;
        
        for(int image = 0; image < TESTING_NUM; image++) {
            int tar = this.targets[image];
            int[][] in = this.inputs[image];
            this.net.setInputs(in); //set the inputs for this TESTING epoch
            this.net.feedForward();
            
            double[] temp = this.net.getOutputs();
            
            // for each target value
            // re-total the output value for each node and increment the firing count (for averaging)
            switch(tar){
                    
                case 0:
                    break;
                    
                case 1: fireThreshold += temp[0];
                    fireCount++;
                    
                    zeroFireThreshold += temp[0];
                    zeroFireCount++;
                    break;
                    
                case 2:  fireThreshold+= temp[1];
                    fireCount++;
                    
                    oneFireThreshold += temp[1];
                    oneFireCount++;
                    break;
                    
                case 3: fireThreshold += temp[0] + temp [1];
                    fireCount += 2;
                    
                    zeroFireThreshold += temp[0];
                    zeroFireCount++;
                    oneFireThreshold += temp[1];
                    oneFireCount++;
                    break;
                    
                case 4: fireThreshold += temp[2];
                    fireCount++;
                    
                    twoFireThreshold += temp[2];
                    twoFireCount++;
                    break;
                    
                case 5: fireThreshold += temp[0] + temp[2];
                    fireCount += 2;
                    
                    zeroFireThreshold += temp[0];
                    zeroFireCount++;
                    twoFireThreshold += temp[2];
                    twoFireCount++;
                    break;
                    
                case 6: fireThreshold += temp[1] + temp[2];
                    fireCount += 2;
                    
                    oneFireThreshold += temp[1];
                    oneFireCount++;
                    twoFireThreshold += temp[2];
                    twoFireCount++;
                    break;
                    
                case 7: fireThreshold += temp[0] + temp[1] + temp[2];
                    fireCount += 3;
                    
                    zeroFireThreshold += temp[0];
                    zeroFireCount++;
                    oneFireThreshold += temp[1];
                    oneFireCount++;
                    twoFireThreshold += temp[2];
                    twoFireCount++;
                    break;
                    
                case 8: fireThreshold += temp[3];
                    fireCount ++;
                    threeFireThreshold += temp[3];
                    threeFireCount++;
                    break;
                    
                case 9: fireThreshold += temp[0] + temp[3];
                    fireCount += 2;
                    
                    zeroFireThreshold += temp[0];
                    zeroFireCount++;
                    threeFireThreshold += temp[3];
                    threeFireCount++;
                    break;
                    
                default:
                    break;
            }
        }
        PrintWriter writer;
        try{
            writer = new PrintWriter("threshold.txt", "UTF-8");
            writer.println("Average threshold: "+fireThreshold/(double)fireCount);
            writer.println("Zero-node threshold: "+zeroFireThreshold/(double)zeroFireCount);
            writer.println("One-node threshold: "+oneFireThreshold/(double)oneFireCount);
            writer.println("Two-node threshold: "+twoFireThreshold/(double)twoFireCount);
            writer.println("Three-node threshold: "+threeFireThreshold/(double)threeFireCount);
            writer.close();
        }catch(IOException e){}
    }
    
}

